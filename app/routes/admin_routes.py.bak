from flask import Blueprint, render_template, request, redirect, url_for, flash, jsonify
from flask_login import login_required, current_user
from app import db
from app.models.user import User
from app.models.course import Course
from app.models.lecture import Lecture
from app.models.department import Department
from app.models.activity_log import ActivityLog
from app.models.system_settings import SystemSettings
from app.forms.settings import SystemSettingsForm
from app.utils.decorators import admin_required
from datetime import datetime, timedelta
from sqlalchemy import func, desc
import psutil
import pytz
import requests
from typing import Dict, Any, Optional

admin_bp = Blueprint('admin', __name__)

# ESP8266 Configuration
ESP8266_IP = "192.168.1.100"  # e.g., "192.168.1.100"
ESP8266_PORT = 80  # e.g., 80
ESP8266_BASE_URL = f"http://{ESP8266_IP}:{ESP8266_PORT}"

def send_to_esp8266(endpoint: str, data: Dict[str, Any]) -> Dict[str, Any]:
    """Send commands to ESP8266 with proper error handling"""
    try:
        response = requests.post(
            f"{ESP8266_BASE_URL}/{endpoint}",
            json=data,
            timeout=5  # 5 seconds timeout
        )
        response.raise_for_status()  # Raise an error for bad status codes
        return response.json()
    except requests.exceptions.RequestException as e:
        return {'success': False, 'error': f'Failed to communicate with ESP8266: {str(e)}'}
    except ValueError as e:  # JSON decode error
        return {'success': False, 'error': f'Invalid response from ESP8266: {str(e)}'}

def get_nigeria_time() -> datetime:
    """Get current time in Nigeria timezone with error handling"""
    try:
        lagos_tz = pytz.timezone('Africa/Lagos')
        return datetime.now(lagos_tz)
    except pytz.exceptions.UnknownTimeZoneError:
        return datetime.now()  # Fallback to system time if timezone is unknown

@admin_bp.before_request
def require_admin():
    """Ensure only admin users can access these routes"""
    if not current_user.is_authenticated or current_user.role != 'admin':
        flash('You do not have permission to access this page.', 'error')
        return redirect(url_for('main.index'))

@admin_bp.route('/')
@admin_bp.route('/dashboard')
@login_required
@admin_required
def dashboard():
    """Render the admin dashboard with error handling"""
    try:
        current_time = get_nigeria_time()
        
        # Get counts with error handling
        try:
            total_students = User.query.filter_by(role='student').count()
            total_lecturers = User.query.filter_by(role='lecturer').count()
            total_departments = Department.query.count()
            total_courses = Course.query.count()
        except Exception as e:
            flash(f'Error fetching statistics: {str(e)}', 'error')
            total_students = total_lecturers = total_departments = total_courses = 0

        # Get system info with error handling
        try:
            cpu_percent = psutil.cpu_percent()
            memory = psutil.virtual_memory()
            disk = psutil.disk_usage('/')
        except Exception as e:
            flash(f'Error fetching system info: {str(e)}', 'error')
            cpu_percent = memory = disk = None

        # Get recent activity with error handling
        try:
            recent_activity = ActivityLog.query.order_by(
                ActivityLog.created_at.desc()
            ).limit(5).all()
        except Exception as e:
            flash(f'Error fetching recent activity: {str(e)}', 'error')
            recent_activity = []

        # Get course attendance statistics
        course_attendance_stats = db.session.query(
            Course.title,
            func.count(Lecture.id).label('total_lectures'),
            func.avg(func.count(Lecture.id)).over(partition_by=Course.id).label('avg_attendance')
        ).join(
            Lecture, Course.id == Lecture.course_id
        ).group_by(
            Course.id, Course.title
        ).order_by(
            desc('total_lectures')
        ).limit(5).all()

        # Format course stats for template
        formatted_course_stats = [{
            'name': stat.title,
            'total_lectures': stat.total_lectures,
            'avg_attendance': float(stat.avg_attendance or 0)
        } for stat in course_attendance_stats]

        # Get user activity stats for the past week
        past_week = datetime.now() - timedelta(days=7)
        user_activity_stats = []
        
        for i in range(7):
            date = past_week + timedelta(days=i)
            count = ActivityLog.query.filter(
                func.date(ActivityLog.created_at) == date.date()
            ).count()
            user_activity_stats.append({
                'date': date.strftime('%Y-%m-%d'),
                'count': count
            })

        # Get ESP8266 status
        try:
            esp_status = requests.get(f"{ESP8266_BASE_URL}/status", timeout=2).json()
            hardware_connected = esp_status.get('connected', False)
        except:
            hardware_connected = False

        return render_template('admin/dashboard_new.html',
            current_time=current_time,
            total_students=total_students,
            total_lecturers=total_lecturers,
            total_departments=total_departments,
            total_courses=total_courses,
            cpu_percent=cpu_percent,
            memory=memory,
            disk=disk,
            recent_activity=recent_activity,
            course_attendance_stats=formatted_course_stats,
            user_activity_stats=user_activity_stats,
            hardware_connected=hardware_connected
        )
    except Exception as e:
        flash(f'Error loading dashboard: {str(e)}', 'error')
        return redirect(url_for('main.index'))

@admin_bp.route('/users')
@login_required
@admin_required
def manage_users():
    page = request.args.get('page', 1, type=int)
    per_page = 10  # Number of items per page
    
    # Get users with pagination
    users = User.query.paginate(
        page=page,
        per_page=per_page,
        error_out=False
    )
    
    departments = Department.query.all()
    
    return render_template('admin/users_new.html',
                         users=users.items,  # Access the items from pagination
                         pagination=users,
                         departments=departments)

@admin_bp.route('/users/<int:user_id>/toggle-status', methods=['POST'])
@login_required
@admin_required
def toggle_user_status(user_id):
    user = User.query.get_or_404(user_id)
    
    # Prevent self-deactivation
    if user.id == current_user.id:
        return jsonify({'success': False, 'message': 'You cannot modify your own account status.'}), 403
    
    try:
        user.is_active = not user.is_active
        db.session.commit()
        
        # Log the activity
        status = 'activated' if user.is_active else 'deactivated'
        ActivityLog.log_activity(
            current_user.id,
            'user_status_change',
            f'User {user.name} ({user.email}) was {status}'
        )
        
        return jsonify({
            'success': True,
            'message': f'User status has been {"activated" if user.is_active else "deactivated"}.',
            'is_active': user.is_active
        })
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'message': str(e)}), 500

@admin_bp.route('/users/bulk-action', methods=['POST'])
@login_required
@admin_required
def bulk_action():
    data = request.get_json()
    action = data.get('action')
    user_ids = data.get('user_ids', [])
    
    if not action or not user_ids:
        return jsonify({
            'success': False,
            'message': 'Invalid request parameters'
        }), 400
    
    try:
        users = User.query.filter(User.id.in_(user_ids)).all()
        for user in users:
            # Skip if trying to modify own account
            if user.id == current_user.id:
                continue
                
            if action == 'activate':
                user.is_active = True
            elif action == 'deactivate':
                user.is_active = False
            elif action == 'delete':
                db.session.delete(user)
        
        db.session.commit()
        return jsonify({
            'success': True,
            'message': 'Bulk action completed successfully'
        })
    except Exception as e:
        db.session.rollback()
        return jsonify({
            'success': False,
            'message': f'Error performing bulk action: {str(e)}'
        }), 500

@admin_bp.route('/users/<int:user_id>/delete', methods=['POST'])
@login_required
@admin_required
def delete_user(user_id):
    user = User.query.get_or_404(user_id)
    
    # Don't allow deleting own account
    if user.id == current_user.id:
        return jsonify({
            'success': False,
            'message': 'You cannot delete your own account.'
        }), 400
    
    try:
        db.session.delete(user)
        db.session.commit()
        return jsonify({
            'success': True,
            'message': 'User deleted successfully'
        })
    except Exception as e:
        db.session.rollback()
        return jsonify({
            'success': False,
            'message': f'Error deleting user: {str(e)}'
        }), 500

@admin_bp.route('/departments')
@login_required
@admin_required
def manage_departments():
    departments = Department.query.all()
    return render_template('admin/departments_new.html', departments=departments)

@admin_bp.route('/add-department', methods=['GET', 'POST'])
@login_required
@admin_required
def add_department():
    if request.method == 'POST':
        try:
            department = Department(
                code=request.form['code'],
                name=request.form['name'],
                description=request.form['description']
            )
            db.session.add(department)
            db.session.commit()
            flash('Department added successfully!', 'success')
            return redirect(url_for('admin.manage_departments'))
        except Exception as e:
            db.session.rollback()
            flash(f'Error adding department: {str(e)}', 'error')
            return redirect(url_for('admin.add_department'))

    return render_template('admin/add_department_new.html')

@admin_bp.route('/edit_department/<int:department_id>', methods=['POST'])
@login_required
@admin_required
def edit_department(department_id):
    try:
        department = Department.query.get_or_404(department_id)
        department.code = request.form['code']
        department.name = request.form['name']
        department.description = request.form['description']
        db.session.commit()
        flash('Department updated successfully!', 'success')
        return redirect(url_for('admin.manage_departments'))
    except Exception as e:
        db.session.rollback()
        flash(f'Error updating department: {str(e)}', 'error')
        return redirect(url_for('admin.manage_departments'))

@admin_bp.route('/delete_department/<int:department_id>', methods=['POST'])
@login_required
@admin_required
def delete_department(department_id):
    try:
        department = Department.query.get_or_404(department_id)
        if department.users or department.courses:
            return jsonify({
                'success': False,
                'message': 'Cannot delete department that has users or courses assigned to it'
            })
        db.session.delete(department)
        db.session.commit()
        return jsonify({'success': True})
    except Exception as e:
        db.session.rollback()
        return jsonify({
            'success': False,
            'message': f'Error deleting department: {str(e)}'
        })

@admin_bp.route('/courses')
@login_required
@admin_required
def manage_courses():
    courses = Course.query.all()
    departments = Department.query.all()
    lecturers = User.query.filter_by(role='lecturer').all()
    return render_template('admin/courses_new.html', 
                         courses=courses,
                         departments=departments,
                         lecturers=lecturers)

@admin_bp.route('/add-course', methods=['POST'])
@login_required
@admin_required
def add_course():
    try:
        course = Course(
            code=request.form['code'],
            name=request.form['name'],
            description=request.form['description'],
            department_id=request.form['department_id'],
            lecturer_id=request.form['lecturer_id'] or None
        )
        db.session.add(course)
        db.session.commit()
        flash('Course added successfully!', 'success')
        return redirect(url_for('admin.manage_courses'))
    except Exception as e:
        db.session.rollback()
        flash(f'Error adding course: {str(e)}', 'error')
        return redirect(url_for('admin.manage_courses'))

@admin_bp.route('/edit_course/<int:course_id>', methods=['POST'])
@login_required
@admin_required
def edit_course(course_id):
    try:
        course = Course.query.get_or_404(course_id)
        course.code = request.form['code']
        course.name = request.form['name']
        course.description = request.form['description']
        course.department_id = request.form['department_id']
        course.lecturer_id = request.form['lecturer_id'] or None
        db.session.commit()
        flash('Course updated successfully!', 'success')
        return redirect(url_for('admin.manage_courses'))
    except Exception as e:
        db.session.rollback()
        flash(f'Error updating course: {str(e)}', 'error')
        return redirect(url_for('admin.manage_courses'))

@admin_bp.route('/delete_course/<int:course_id>', methods=['POST'])
@login_required
@admin_required
def delete_course(course_id):
    try:
        course = Course.query.get_or_404(course_id)
        if course.sessions:
            return jsonify({
                'success': False,
                'message': 'Cannot delete course that has sessions'
            })
        db.session.delete(course)
        db.session.commit()
        return jsonify({'success': True})
    except Exception as e:
        db.session.rollback()
        return jsonify({
            'success': False,
            'message': f'Error deleting course: {str(e)}'
        })

@admin_bp.route('/manage_lectures')
@login_required
@admin_required
def manage_lectures():
    lectures = Lecture.query.all()
    courses = Course.query.all()
    lecturers = User.query.filter_by(role='lecturer').all()
    return render_template('admin/manage_lectures.html', 
                         lectures=lectures,
                         courses=courses,
                         lecturers=lecturers)

@admin_bp.route('/lecture/<int:lecture_id>')
@login_required
@admin_required
def get_lecture(lecture_id):
    lecture = Lecture.query.get_or_404(lecture_id)
    return jsonify({
        'course_id': lecture.course_id,
        'lecturer_id': lecture.lecturer_id,
        'day_of_week': lecture.day_of_week,
        'start_time': lecture.start_time.strftime('%H:%M'),
        'end_time': lecture.end_time.strftime('%H:%M'),
        'topic': lecture.topic
    })

@admin_bp.route('/lecture/add', methods=['POST'])
@login_required
@admin_required
def add_lecture():
    try:
        data = request.form
        # Convert time strings to time objects
        start_time = datetime.strptime(data['start_time'], '%H:%M').time()
        end_time = datetime.strptime(data['end_time'], '%H:%M').time()
        
        # Create a date for the next occurrence of the specified day
        today = datetime.now()
        days = {'Monday': 0, 'Tuesday': 1, 'Wednesday': 2, 'Thursday': 3, 'Friday': 4}
        days_ahead = days[data['day']] - today.weekday()
        if days_ahead <= 0:  # Target day already happened this week
            days_ahead += 7
        next_date = today + timedelta(days=days_ahead)
        
        lecture = Lecture(
            course_id=data['course_id'],
            lecturer_id=data['lecturer_id'],
            date=next_date,
            start_time=start_time,
            end_time=end_time,
            topic=data.get('topic')
        )
        
        db.session.add(lecture)
        db.session.commit()
        
        return jsonify({'success': True, 'message': 'Lecture added successfully'})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'message': str(e)})

@admin_bp.route('/lecture/<int:lecture_id>/edit', methods=['POST'])
@login_required
@admin_required
def edit_lecture(lecture_id):
    try:
        lecture = Lecture.query.get_or_404(lecture_id)
        data = request.form
        
        # Convert time strings to time objects
        start_time = datetime.strptime(data['start_time'], '%H:%M').time()
        end_time = datetime.strptime(data['end_time'], '%H:%M').time()
        
        # Update the date if day_of_week has changed
        if data['day'] != lecture.day_of_week:
            today = datetime.now()
            days = {'Monday': 0, 'Tuesday': 1, 'Wednesday': 2, 'Thursday': 3, 'Friday': 4}
            days_ahead = days[data['day']] - today.weekday()
            if days_ahead <= 0:  # Target day already happened this week
                days_ahead += 7
            next_date = today + timedelta(days=days_ahead)
            lecture.date = next_date
        
        lecture.course_id = data['course_id']
        lecture.lecturer_id = data['lecturer_id']
        lecture.start_time = start_time
        lecture.end_time = end_time
        lecture.topic = data.get('topic')
        
        db.session.commit()
        
        return jsonify({'success': True, 'message': 'Lecture updated successfully'})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'message': str(e)})

@admin_bp.route('/lecture/<int:lecture_id>/delete')
@login_required
@admin_required
def delete_lecture(lecture_id):
    try:
        lecture = Lecture.query.get_or_404(lecture_id)
        db.session.delete(lecture)
        db.session.commit()
        flash('Lecture deleted successfully', 'success')
    except Exception as e:
        db.session.rollback()
        flash(f'Error deleting lecture: {str(e)}', 'error')
    return redirect(url_for('admin.manage_lectures'))

@admin_bp.route('/api/hardware/connect', methods=['POST'])
@login_required
@admin_required
def api_connect_hardware():
    """API endpoint to connect to hardware"""
    try:
        data = request.get_json()
        ip_address = data.get('ip_address')
        
        if not ip_address:
            return jsonify({'success': False, 'message': 'IP address is required'}), 400
            
        # Try to connect to the hardware
        response = send_to_esp8266('connect', {'ip': ip_address})
        
        if response.get('success'):
            return jsonify({'success': True, 'message': 'Successfully connected to hardware'}), 200
        else:
            return jsonify({'success': False, 'message': response.get('error', 'Failed to connect to hardware')}), 500
            
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@admin_bp.route('/api/hardware/disconnect', methods=['POST'])
@login_required
@admin_required
def api_disconnect_hardware():
    """API endpoint to disconnect from hardware"""
    try:
        # Try to disconnect from the hardware
        response = send_to_esp8266('disconnect', {})
        
        if response.get('success'):
            return jsonify({'success': True, 'message': 'Successfully disconnected from hardware'}), 200
        else:
            return jsonify({'success': False, 'message': response.get('error', 'Failed to disconnect from hardware')}), 500
            
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@admin_bp.route('/api/registration/enable', methods=['POST'])
@login_required
@admin_required
def api_enable_registration():
    """API endpoint to enable registration mode"""
    try:
        # Try to enable registration mode
        response = send_to_esp8266('enable_registration', {})
        
        if response.get('success'):
            return jsonify({'success': True, 'message': 'Registration mode enabled'}), 200
        else:
            return jsonify({'success': False, 'message': response.get('error', 'Failed to enable registration mode')}), 500
            
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@admin_bp.route('/api/registration/disable', methods=['POST'])
@login_required
@admin_required
def api_disable_registration():
    """API endpoint to disable registration mode"""
    try:
        # Try to disable registration mode
        response = send_to_esp8266('disable_registration', {})
        
        if response.get('success'):
            return jsonify({'success': True, 'message': 'Registration mode disabled'}), 200
        else:
            return jsonify({'success': False, 'message': response.get('error', 'Failed to disable registration mode')}), 500
            
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@admin_bp.route('/api/registration/data', methods=['GET'])
@login_required
@admin_required
def api_get_registration_data():
    """API endpoint to get registration data (RFID and fingerprint)"""
    try:
        # Try to get registration data
        response = send_to_esp8266('get_registration_data', {})
        
        if response.get('success'):
            return jsonify({
                'success': True,
                'rfid_data': response.get('rfid_data'),
                'fingerprint_data': response.get('fingerprint_data')
            }), 200
        else:
            return jsonify({'success': False, 'message': response.get('error', 'Failed to get registration data')}), 500
            
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@admin_bp.route('/register_user', methods=['GET', 'POST'])
@login_required
@admin_required
def register_user():
    if request.method == 'POST':
        try:
            # Get form data
            name = request.form.get('name')
            matric_number = request.form.get('matric_number')
            department_id = request.form.get('department')
            role = request.form.get('role')
            rfid_tag = request.form.get('rfid_tag')
            fingerprint_template = request.form.get('fingerprint_template')

            # Validate required fields
            if not all([name, matric_number, department_id, role, rfid_tag, fingerprint_template]):
                flash('All fields are required', 'error')
                return redirect(url_for('admin.register_user'))

            # Create new user
            user = User(
                name=name,
                matric_number=matric_number,
                department_id=department_id,
                role=role,
                rfid_tag=rfid_tag,
                fingerprint_template=fingerprint_template,
                password=generate_password_hash(matric_number)  # Use matric number as default password
            )

            db.session.add(user)
            db.session.commit()

            flash('User registered successfully', 'success')
            return redirect(url_for('admin.manage_users'))

        except Exception as e:
            db.session.rollback()
            flash(f'Error registering user: {str(e)}', 'error')
            return redirect(url_for('admin.register_user'))

    # GET request - render registration form
    departments = Department.query.all()
    return render_template('admin/register_user.html', departments=departments)

@admin_bp.route('/settings', methods=['GET', 'POST'])
@login_required
@admin_required
def settings():
    form = SystemSettingsForm()
    settings = SystemSettings.get_settings()
    
    if request.method == 'POST':
        if form.validate_on_submit():
            try:
                settings.system_name = form.system_name.data
                settings.academic_year = form.academic_year.data
                settings.semester = form.semester.data
                settings.late_threshold = form.late_threshold.data
                settings.attendance_threshold = form.attendance_threshold.data
                settings.last_updated = datetime.utcnow()
                
                db.session.commit()
                
                # Log the activity
                ActivityLog.log_activity(
                    current_user.id,
                    'settings',
                    'update',
                    'Updated system settings'
                )
                
                return jsonify({'success': True})
            except Exception as e:
                db.session.rollback()
                return jsonify({'success': False, 'message': str(e)})
        else:
            return jsonify({'success': False, 'message': 'Invalid form data'})
    
    # GET request - populate form with current settings
    form.system_name.data = settings.system_name
    form.academic_year.data = settings.academic_year
    form.semester.data = settings.semester
    form.late_threshold.data = settings.late_threshold
    form.attendance_threshold.data = settings.attendance_threshold
    
    return render_template('admin/settings_new.html', form=form)

@admin_bp.route('/settings/hardware', methods=['POST'])
@login_required
@admin_required
def settings_hardware_control():
    data = request.get_json()
    action = data.get('action')
    
    try:
        settings = SystemSettings.get_settings()
        
        if action == 'connect':
            # Try to connect to the hardware
            response = send_to_esp8266('connect', {})
            if response.get('success'):
                settings.hardware_connected = True
                settings.last_hardware_check = datetime.utcnow()
                message = 'Hardware connected successfully'
            else:
                return jsonify({'success': False, 'message': response.get('error', 'Failed to connect to hardware')})
        else:
            # Disconnect from hardware
            response = send_to_esp8266('disconnect', {})
            settings.hardware_connected = False
            settings.last_hardware_check = datetime.utcnow()
            message = 'Hardware disconnected successfully'
        
        db.session.commit()
        
        # Log the activity
        ActivityLog.log_activity(
            current_user.id,
            'hardware',
            action,
            f'Hardware {action}ed'
        )
        
        return jsonify({'success': True, 'message': message})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'message': str(e)})

@admin_bp.route('/settings/registration', methods=['POST'])
@login_required
@admin_required
def settings_registration_control():
    data = request.get_json()
    enabled = data.get('enabled', False)
    
    try:
        settings = SystemSettings.get_settings()
        settings.registration_mode = enabled
        db.session.commit()
        
        # Log the activity
        ActivityLog.log_activity(
            current_user.id,
            'registration',
            'enable' if enabled else 'disable',
            f'Registration mode {"enabled" if enabled else "disabled"}'
        )
        
        return jsonify({
            'success': True,
            'message': f'Registration mode {"enabled" if enabled else "disabled"} successfully'
        })
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'message': str(e)})

@admin_bp.route('/settings/reset', methods=['POST'])
@login_required
@admin_required
def reset_settings():
    try:
        settings = SystemSettings.get_settings()
        
        # Reset to default values
        settings.system_name = 'Attendance Management System'
        settings.late_threshold = 15
        settings.attendance_threshold = 75
        settings.last_updated = datetime.utcnow()
        
        db.session.commit()
        
        # Log the activity
        ActivityLog.log_activity(
            current_user.id,
            'settings',
            'reset',
            'Reset system settings to defaults'
        )
        
        return jsonify({'success': True, 'message': 'Settings reset to defaults successfully'})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'message': str(e)})

@admin_bp.route('/settings/info')
@login_required
@admin_required
def get_system_info():
    try:
        settings = SystemSettings.get_settings()
        
        # Get system metrics
        cpu_percent = psutil.cpu_percent()
        memory = psutil.virtual_memory()
        disk = psutil.disk_usage('/')
        
        # Determine system health based on metrics
        health_status = 'Healthy'
        if cpu_percent > 80 or memory.percent > 80 or disk.percent > 80:
            health_status = 'Warning'
        if cpu_percent > 90 or memory.percent > 90 or disk.percent > 90:
            health_status = 'Critical'
        
        return jsonify({
            'version': settings.version,
            'health': health_status,
            'last_updated': settings.last_updated.strftime('%Y-%m-%d %H:%M:%S') if settings.last_updated else 'Never',
            'db_status': 'Connected',
            'hardware_connected': settings.hardware_connected,
            'registration_mode': settings.registration_mode,
            'metrics': {
                'cpu': cpu_percent,
                'memory': memory.percent,
                'disk': disk.percent
            }
        })
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)})

@admin_bp.route('/api/hardware/<action>', methods=['POST'])
@login_required
@admin_required
def hardware_control(action):
    if action not in ['connect', 'disconnect']:
        return jsonify({'status': 'error', 'message': 'Invalid action'}), 400
    
    try:
        # Implement hardware connection logic here
        return jsonify({'status': 'success'})
    except Exception as e:
        return jsonify({'status': 'error', 'message': str(e)}), 500

@admin_bp.route('/api/<action>', methods=['POST'])
@login_required
@admin_required
def registration_control(action):
    if action not in ['enable_registration', 'disable_registration']:
        return jsonify({'status': 'error', 'message': 'Invalid action'}), 400
    
    try:
        # Implement registration mode logic here
        return jsonify({'status': 'success'})
    except Exception as e:
        return jsonify({'status': 'error', 'message': str(e)}), 500

@admin_bp.route('/users/<int:user_id>/edit', methods=['GET', 'POST'])
@login_required
@admin_required
def edit_user(user_id):
    user = User.query.get_or_404(user_id)
    departments = Department.query.order_by(Department.name).all()
    
    if request.method == 'POST':
        try:
            # Update basic info
            user.name = request.form.get('name')
            user.email = request.form.get('email')
            user.role = request.form.get('role')
            
            # Handle department
            department_id = request.form.get('department_id')
            if department_id and department_id.strip():
                department = Department.query.get(int(department_id))
                if department:
                    user.department = department
                else:
                    flash('Selected department does not exist', 'error')
                    return redirect(url_for('admin.edit_user', user_id=user_id))
            else:
                user.department = None
            
            db.session.commit()
            
            # Log the activity
            ActivityLog.log_activity(
                user_id=current_user.id,
                action=f"Updated user {user.name} (ID: {user.id})",
                category="user_management"
            )
            
            flash('User updated successfully', 'success')
            return redirect(url_for('admin.manage_users'))

        except Exception as e:
            db.session.rollback()
            flash(f'Error updating user: {str(e)}', 'error')
            return redirect(url_for('admin.edit_user', user_id=user_id))
    
    return render_template('admin/edit_user.html', user=user, departments=departments)
